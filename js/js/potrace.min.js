var Potrace = (function() {
    function t(w, z) {
        this.x = w;
        this.y = z
    }
    t.prototype.copy = function() {
        return new t(this.x, this.y)
    };
    function f(x, y) {
        this.w = x;
        this.h = y;
        this.size = x * y;
        this.arraybuffer = new ArrayBuffer(this.size);
        this.data = new Int8Array(this.arraybuffer)
    }
    f.prototype.at = function(w, z) {
        return (w >= 0 && w < this.w && z >= 0 && z < this.h) && this.data[this.w * z + w] === 1
    };
    f.prototype.index = function(x) {
        var w = new t();
        w.y = Math.floor(x / this.w);
        w.x = x - w.y * this.w;
        return w
    };
    f.prototype.flip = function(w, z) {
        if (this.at(w, z)) {
            this.data[this.w * z + w] = 0
        } else {
            this.data[this.w * z + w] = 1
        }
    };
    f.prototype.copy = function() {
        var x = new f(this.w, this.h),
        w;
        for (w = 0; w < this.size; w++) {
            x.data[w] = this.data[w]
        }
        return x
    };
    function q() {
        this.area = 0;
        this.len = 0;
        this.curve = {};
        this.pt = [];
        this.minX = 100000;
        this.minY = 100000;
        this.maxX = -1;
        this.maxY = -1
    }
    function p(w) {
        this.n = w;
        this.tag = new Array(w);
        this.c = new Array(w * 3);
        this.alphaCurve = 0;
        this.vertex = new Array(w);
        this.alpha = new Array(w);
        this.alpha0 = new Array(w);
        this.beta = new Array(w)
    }
    var h = document.createElement("img"),
    e = document.createElement("canvas"),
    a = null,
    g = [],
    c,
    r = {
        isReady: false,
        turnpolicy: "minority",
        turdsize: 2,
        optcurve: true,
        alphamax: 1,
        opttolerance: 0.2,
        bmgray: 128,
        bmgrayNO: false,
        maxSize: 0
    };
    h.onload = function() {
        m();
        l()
    };
    function b(x) {
        if (r.isReady) {
            k()
        }
        h.file = x;
        var w = new FileReader();
        w.onload = (function(y) {
            return function(z) {
                y.src = z.target.result
            }
        })(h);
        w.readAsDataURL(x)
    }
    function v(w) {
        if (r.isReady) {
            k()
        }
        h.src = w
    }
    function u(x) {
        var w;
        for (w in x) {
            if (r.hasOwnProperty(w)) {
                r[w] = x[w]
            }
        }
    }
    function m() {
        if (r.maxSize > 0) {
            var z = h.width / h.height;
            var w = Math.min(Math.max(h.width, h.height), r.maxSize);
            var A = z >= 1 ? w: w * z;
            var y = z >= 1 ? w / z: w;
            e.width = A;
            e.height = y;
            var x = e.getContext("2d");
            x.drawImage(h, 0, 0, A, y)
        } else {
            e.width = h.width;
            e.height = h.height;
            var x = e.getContext("2d");
            x.drawImage(h, 0, 0)
        }
    }
    function l() {
        var y = e.getContext("2d");
        a = new f(e.width, e.height);
        var w = y.getImageData(0, 0, a.w, a.h);
        var x = w.data.length,
        B, A, z;
        for (B = 0, A = 0; B < x; B += 4, A++) {
            z = 0.2126 * w.data[B] + 0.7153 * w.data[B + 1] + 0.0721 * w.data[B + 2];
            if (w.data[B + 3] == 0) {
                z = 255
            }
            if (!r.bmgrayNO) {
                a.data[A] = (z < r.bmgray ? 1 : 0)
            } else {
                a.data[A] = (z < r.bmgray ? 0 : 1)
            }
        }
        r.isReady = true
    }
    function i() {
        var A = a.copy(),
        C = new t(0, 0),
        B;
        function x(D) {
            var E = A.w * D.y + D.x;
            while (E < A.size && A.data[E] !== 1) {
                E++
            }
            return E < A.size && A.index(E)
        }
        function w(D, H) {
            var G, E, F;
            for (G = 2; G < 5; G++) {
                F = 0;
                for (E = -G + 1; E <= G - 1; E++) {
                    F += A.at(D + E, H + G - 1) ? 1 : -1;
                    F += A.at(D + G - 1, H + E - 1) ? 1 : -1;
                    F += A.at(D + E - 1, H - G) ? 1 : -1;
                    F += A.at(D - G, H + E) ? 1 : -1
                }
                if (F > 0) {
                    return 1
                } else {
                    if (F < 0) {
                        return 0
                    }
                }
            }
            return 0
        }
        function z(J) {
            var L = new q(),
            H = J.x,
            G = J.y,
            K = 0,
            I = 1,
            F;
            L.sign = a.at(J.x, J.y) ? "+": "-";
            while (1) {
                L.pt.push(new t(H, G));
                if (H > L.maxX) {
                    L.maxX = H
                }
                if (H < L.minX) {
                    L.minX = H
                }
                if (G > L.maxY) {
                    L.maxY = G
                }
                if (G < L.minY) {
                    L.minY = G
                }
                L.len++;
                H += K;
                G += I;
                L.area -= H * I;
                if (H === J.x && G === J.y) {
                    break
                }
                var E = A.at(H + (K + I - 1) / 2, G + (I - K - 1) / 2);
                var D = A.at(H + (K - I - 1) / 2, G + (I + K - 1) / 2);
                if (D && !E) {
                    if (r.turnpolicy === "right" || (r.turnpolicy === "black" && L.sign === "+") || (r.turnpolicy === "white" && L.sign === "-") || (r.turnpolicy === "majority" && w(H, G)) || (r.turnpolicy === "minority" && !w(H, G))) {
                        F = K;
                        K = -I;
                        I = F
                    } else {
                        F = K;
                        K = I;
                        I = -F
                    }
                } else {
                    if (D) {
                        F = K;
                        K = -I;
                        I = F
                    } else {
                        if (!E) {
                            F = K;
                            K = I;
                            I = -F
                        }
                    }
                }
            }
            return L
        }
        function y(L) {
            var J = L.pt[0].y,
            H = L.len,
            K,
            I,
            D,
            E,
            G,
            F;
            for (G = 1; G < H; G++) {
                K = L.pt[G].x;
                I = L.pt[G].y;
                if (I !== J) {
                    E = J < I ? J: I;
                    D = L.maxX;
                    for (F = K; F < D; F++) {
                        A.flip(F, E)
                    }
                    J = I
                }
            }
        }
        while (C = x(C)) {
            B = z(C);
            y(B);
            if (B.area > r.turdsize) {
                g.push(B)
            }
        }
    }
    function n() {
        function L() {
            this.data = [0, 0, 0, 0, 0, 0, 0, 0, 0]
        }
        L.prototype.at = function(W, X) {
            return this.data[W * 3 + X]
        };
        function E(W, aa, Z, X, Y) {
            this.x = W;
            this.y = aa;
            this.xy = Z;
            this.x2 = X;
            this.y2 = Y
        }
        function U(W, X) {
            return W >= X ? W % X: W >= 0 ? W: X - 1 - ( - 1 - W) % X
        }
        function F(X, W) {
            return X.x * W.y - X.y * W.x
        }
        function R(X, W, Y) {
            if (X <= Y) {
                return (X <= W && W < Y)
            } else {
                return (X <= W || W < Y)
            }
        }
        function T(W) {
            return W > 0 ? 1 : W < 0 ? -1 : 0
        }
        function V(ab, W) {
            var X = new Array(3),
            Z,
            Y,
            aa;
            X[0] = W.x;
            X[1] = W.y;
            X[2] = 1;
            aa = 0;
            for (Z = 0; Z < 3; Z++) {
                for (Y = 0; Y < 3; Y++) {
                    aa += X[Z] * ab.at(Z, Y) * X[Y]
                }
            }
            return aa
        }
        function S(Y, X, W) {
            var Z = new t();
            Z.x = X.x + Y * (W.x - X.x);
            Z.y = X.y + Y * (W.y - X.y);
            return Z
        }
        function A(Y, X) {
            var W = new t();
            W.y = T(X.x - Y.x);
            W.x = -T(X.y - Y.y);
            return W
        }
        function y(Y, X) {
            var W = A(Y, X);
            return W.y * (X.x - Y.x) - W.x * (X.y - Y.y)
        }
        function P(ac, ab, aa) {
            var X, Z, W, Y;
            X = ab.x - ac.x;
            Z = ab.y - ac.y;
            W = aa.x - ac.x;
            Y = aa.y - ac.y;
            return X * Y - W * Z
        }
        function G(ad, ac, ab, aa) {
            var X, Z, W, Y;
            X = ac.x - ad.x;
            Z = ac.y - ad.y;
            W = aa.x - ab.x;
            Y = aa.y - ab.y;
            return X * Y - W * Z
        }
        function x(ac, ab, aa) {
            var X, Z, W, Y;
            X = ab.x - ac.x;
            Z = ab.y - ac.y;
            W = aa.x - ac.x;
            Y = aa.y - ac.y;
            return X * W + Z * Y
        }
        function z(ad, ac, ab, aa) {
            var X, Z, W, Y;
            X = ac.x - ad.x;
            Z = ac.y - ad.y;
            W = aa.x - ab.x;
            Y = aa.y - ab.y;
            return X * W + Z * Y
        }
        function B(X, W) {
            return Math.sqrt((X.x - W.x) * (X.x - W.x) + (X.y - W.y) * (X.y - W.y))
        }
        function H(X, ac, ab, aa, Z) {
            var Y = 1 - X,
            W = new t();
            W.x = Y * Y * Y * ac.x + 3 * (Y * Y * X) * ab.x + 3 * (X * X * Y) * aa.x + X * X * X * Z.x;
            W.y = Y * Y * Y * ac.y + 3 * (Y * Y * X) * ab.y + 3 * (X * X * Y) * aa.y + X * X * X * Z.y;
            return W
        }
        function D(ak, aj, ai, ah, ac, ab) {
            var Z, X, W, ag, af, ae, ad, al, aa, Y;
            Z = G(ak, aj, ac, ab);
            X = G(aj, ai, ac, ab);
            W = G(ai, ah, ac, ab);
            ag = Z - 2 * X + W;
            af = -2 * Z + 2 * X;
            ae = Z;
            ad = af * af - 4 * ag * ae;
            if (ag === 0 || ad < 0) {
                return - 1
            }
            al = Math.sqrt(ad);
            aa = ( - af + al) / (2 * ag);
            Y = ( - af - al) / (2 * ag);
            if (aa >= 0 && aa <= 1) {
                return aa
            } else {
                if (Y >= 0 && Y <= 1) {
                    return Y
                } else {
                    return - 1
                }
            }
        }
        function O(Z) {
            var X, W, aa;
            Z.x0 = Z.pt[0].x;
            Z.y0 = Z.pt[0].y;
            Z.sums = [];
            var Y = Z.sums;
            Y.push(new E(0, 0, 0, 0, 0));
            for (X = 0; X < Z.len; X++) {
                W = Z.pt[X].x - Z.x0;
                aa = Z.pt[X].y - Z.y0;
                Y.push(new E(Y[X].x + W, Y[X].y + aa, Y[X].xy + W * aa, Y[X].x2 + W * W, Y[X].y2 + aa * aa))
            }
        }
        function Q(ab) {
            var af = ab.len,
            ad = ab.pt,
            ac, ae = new Array(af),
            Z = new Array(af),
            Y = new Array(4);
            ab.lon = new Array(af);
            var W = [new t(), new t()],
            X = new t(),
            ao = new t(),
            ai = new t(),
            ap;
            var aj, ah, aa, an, am, al, ak, ag = 0;
            for (aj = af - 1; aj >= 0; aj--) {
                if (ad[aj].x != ad[ag].x && ad[aj].y != ad[ag].y) {
                    ag = aj + 1
                }
                Z[aj] = ag
            }
            for (aj = af - 1; aj >= 0; aj--) {
                Y[0] = Y[1] = Y[2] = Y[3] = 0;
                ac = (3 + 3 * (ad[U(aj + 1, af)].x - ad[aj].x) + (ad[U(aj + 1, af)].y - ad[aj].y)) / 2;
                Y[ac]++;
                W[0].x = 0;
                W[0].y = 0;
                W[1].x = 0;
                W[1].y = 0;
                ag = Z[aj];
                aa = aj;
                while (1) {
                    ap = 0;
                    ac = (3 + 3 * T(ad[ag].x - ad[aa].x) + T(ad[ag].y - ad[aa].y)) / 2;
                    Y[ac]++;
                    if (Y[0] && Y[1] && Y[2] && Y[3]) {
                        ae[aj] = aa;
                        ap = 1;
                        break
                    }
                    X.x = ad[ag].x - ad[aj].x;
                    X.y = ad[ag].y - ad[aj].y;
                    if (F(W[0], X) < 0 || F(W[1], X) > 0) {
                        break
                    }
                    if (Math.abs(X.x) <= 1 && Math.abs(X.y) <= 1) {} else {
                        ao.x = X.x + ((X.y >= 0 && (X.y > 0 || X.x < 0)) ? 1 : -1);
                        ao.y = X.y + ((X.x <= 0 && (X.x < 0 || X.y < 0)) ? 1 : -1);
                        if (F(W[0], ao) >= 0) {
                            W[0].x = ao.x;
                            W[0].y = ao.y
                        }
                        ao.x = X.x + ((X.y <= 0 && (X.y < 0 || X.x < 0)) ? 1 : -1);
                        ao.y = X.y + ((X.x >= 0 && (X.x > 0 || X.y < 0)) ? 1 : -1);
                        if (F(W[1], ao) <= 0) {
                            W[1].x = ao.x;
                            W[1].y = ao.y
                        }
                    }
                    aa = ag;
                    ag = Z[aa];
                    if (!R(ag, aj, aa)) {
                        break
                    }
                }
                if (ap === 0) {
                    ai.x = T(ad[ag].x - ad[aa].x);
                    ai.y = T(ad[ag].y - ad[aa].y);
                    X.x = ad[aa].x - ad[aj].x;
                    X.y = ad[aa].y - ad[aj].y;
                    an = F(W[0], X);
                    am = F(W[0], ai);
                    al = F(W[1], X);
                    ak = F(W[1], ai);
                    ah = 10000000;
                    if (am < 0) {
                        ah = Math.floor(an / -am)
                    }
                    if (ak > 0) {
                        ah = Math.min(ah, Math.floor( - al / ak))
                    }
                    ae[aj] = U(aa + ah, af)
                }
            }
            ah = ae[af - 1];
            ab.lon[af - 1] = ah;
            for (aj = af - 2; aj >= 0; aj--) {
                if (R(aj + 1, ae[aj], ah)) {
                    ah = ae[aj]
                }
                ab.lon[aj] = ah
            }
            for (aj = af - 1; R(U(aj + 1, af), ah, ab.lon[aj]); aj--) {
                ab.lon[aj] = ah
            }
        }
        function w(al) {
            function ah(aw, aB, aA) {
                var ay = aw.len,
                ax = aw.pt,
                aq = aw.sums;
                var ap, ao, an, aC, am, az, aH, aG, aF, at, av, ar, aE, aD, au = 0;
                if (aA >= ay) {
                    aA -= ay;
                    au = 1
                }
                if (au === 0) {
                    ap = aq[aA + 1].x - aq[aB].x;
                    ao = aq[aA + 1].y - aq[aB].y;
                    aC = aq[aA + 1].x2 - aq[aB].x2;
                    an = aq[aA + 1].xy - aq[aB].xy;
                    am = aq[aA + 1].y2 - aq[aB].y2;
                    az = aA + 1 - aB
                } else {
                    ap = aq[aA + 1].x - aq[aB].x + aq[ay].x;
                    ao = aq[aA + 1].y - aq[aB].y + aq[ay].y;
                    aC = aq[aA + 1].x2 - aq[aB].x2 + aq[ay].x2;
                    an = aq[aA + 1].xy - aq[aB].xy + aq[ay].xy;
                    am = aq[aA + 1].y2 - aq[aB].y2 + aq[ay].y2;
                    az = aA + 1 - aB + ay
                }
                av = (ax[aB].x + ax[aA].x) / 2 - ax[0].x;
                ar = (ax[aB].y + ax[aA].y) / 2 - ax[0].y;
                aD = (ax[aA].x - ax[aB].x);
                aE = -(ax[aA].y - ax[aB].y);
                aH = ((aC - 2 * ap * av) / az + av * av);
                aG = ((an - ap * ar - ao * av) / az + av * ar);
                aF = ((am - 2 * ao * ar) / az + ar * ar);
                at = aE * aE * aH + 2 * aE * aD * aG + aD * aD * aF;
                return Math.sqrt(at)
            }
            var af, ad, Z, ac, Y = al.len,
            ae = new Array(Y + 1),
            aa = new Array(Y + 1),
            ak = new Array(Y),
            ai = new Array(Y + 1),
            W = new Array(Y + 1),
            aj = new Array(Y + 1),
            X,
            ab,
            ag;
            for (af = 0; af < Y; af++) {
                ag = U(al.lon[U(af - 1, Y)] - 1, Y);
                if (ag == af) {
                    ag = U(af + 1, Y)
                }
                if (ag < af) {
                    ak[af] = Y
                } else {
                    ak[af] = ag
                }
            }
            ad = 1;
            for (af = 0; af < Y; af++) {
                while (ad <= ak[af]) {
                    ai[ad] = af;
                    ad++
                }
            }
            af = 0;
            for (ad = 0; af < Y; ad++) {
                W[ad] = af;
                af = ak[af]
            }
            W[ad] = Y;
            Z = ad;
            af = Y;
            for (ad = Z; ad > 0; ad--) {
                aj[ad] = af;
                af = ai[af]
            }
            aj[0] = 0;
            ae[0] = 0;
            for (ad = 1; ad <= Z; ad++) {
                for (af = aj[ad]; af <= W[ad]; af++) {
                    ab = -1;
                    for (ac = W[ad - 1]; ac >= ai[af]; ac--) {
                        X = ah(al, ac, af) + ae[ac];
                        if (ab < 0 || X < ab) {
                            aa[af] = ac;
                            ab = X
                        }
                    }
                    ae[af] = ab
                }
            }
            al.m = Z;
            al.po = new Array(Z);
            for (af = Y, ad = Z - 1; af > 0; ad--) {
                af = aa[af];
                al.po[ad] = af
            }
        }
        function M(ah) {
            function ar(aG, aM, aL, aO, aH) {
                var aI = aG.len,
                aE = aG.sums,
                aD, aC, aN, aB, aA, aK, aR, aQ, aP, az, aJ, aF = 0;
                while (aL >= aI) {
                    aL -= aI;
                    aF += 1
                }
                while (aM >= aI) {
                    aM -= aI;
                    aF -= 1
                }
                while (aL < 0) {
                    aL += aI;
                    aF -= 1
                }
                while (aM < 0) {
                    aM += aI;
                    aF += 1
                }
                aD = aE[aL + 1].x - aE[aM].x + aF * aE[aI].x;
                aC = aE[aL + 1].y - aE[aM].y + aF * aE[aI].y;
                aN = aE[aL + 1].x2 - aE[aM].x2 + aF * aE[aI].x2;
                aB = aE[aL + 1].xy - aE[aM].xy + aF * aE[aI].xy;
                aA = aE[aL + 1].y2 - aE[aM].y2 + aF * aE[aI].y2;
                aK = aL + 1 - aM + aF * aI;
                aO.x = aD / aK;
                aO.y = aC / aK;
                aR = (aN - aD * aD / aK) / aK;
                aQ = (aB - aD * aC / aK) / aK;
                aP = (aA - aC * aC / aK) / aK;
                az = (aR + aP + Math.sqrt((aR - aP) * (aR - aP) + 4 * aQ * aQ)) / 2;
                aR -= az;
                aP -= az;
                if (Math.abs(aR) >= Math.abs(aP)) {
                    aJ = Math.sqrt(aR * aR + aQ * aQ);
                    if (aJ !== 0) {
                        aH.x = -aQ / aJ;
                        aH.y = aR / aJ
                    }
                } else {
                    aJ = Math.sqrt(aP * aP + aQ * aQ);
                    if (aJ !== 0) {
                        aH.x = -aP / aJ;
                        aH.y = aQ / aJ
                    }
                }
                if (aJ === 0) {
                    aH.x = aH.y = 0
                }
            }
            var al = ah.m,
            av = ah.po,
            ak = ah.len,
            aj = ah.pt,
            ax = ah.x0,
            W = ah.y0,
            aw = new Array(al),
            ai = new Array(al),
            ag = new Array(al),
            ad = new Array(3),
            ay,
            au,
            at,
            aq,
            an,
            ae = new t();
            ah.curve = new p(al);
            for (au = 0; au < al; au++) {
                at = av[U(au + 1, al)];
                at = U(at - av[au], ak) + av[au];
                aw[au] = new t();
                ai[au] = new t();
                ar(ah, av[au], at, aw[au], ai[au])
            }
            for (au = 0; au < al; au++) {
                ag[au] = new L();
                ay = ai[au].x * ai[au].x + ai[au].y * ai[au].y;
                if (ay === 0) {
                    for (at = 0; at < 3; at++) {
                        for (aq = 0; aq < 3; aq++) {
                            ag[au].data[at * 3 + aq] = 0
                        }
                    }
                } else {
                    ad[0] = ai[au].y;
                    ad[1] = -ai[au].x;
                    ad[2] = -ad[1] * aw[au].y - ad[0] * aw[au].x;
                    for (an = 0; an < 3; an++) {
                        for (aq = 0; aq < 3; aq++) {
                            ag[au].data[an * 3 + aq] = ad[an] * ad[aq] / ay
                        }
                    }
                }
            }
            var Y, ab, ac, aa, X, am, ap, af, ao, Z;
            for (au = 0; au < al; au++) {
                Y = new L();
                ab = new t();
                ae.x = aj[av[au]].x - ax;
                ae.y = aj[av[au]].y - W;
                at = U(au - 1, al);
                for (an = 0; an < 3; an++) {
                    for (aq = 0; aq < 3; aq++) {
                        Y.data[an * 3 + aq] = ag[at].at(an, aq) + ag[au].at(an, aq)
                    }
                }
                while (1) {
                    X = Y.at(0, 0) * Y.at(1, 1) - Y.at(0, 1) * Y.at(1, 0);
                    if (X !== 0) {
                        ab.x = ( - Y.at(0, 2) * Y.at(1, 1) + Y.at(1, 2) * Y.at(0, 1)) / X;
                        ab.y = (Y.at(0, 2) * Y.at(1, 0) - Y.at(1, 2) * Y.at(0, 0)) / X;
                        break
                    }
                    if (Y.at(0, 0) > Y.at(1, 1)) {
                        ad[0] = -Y.at(0, 1);
                        ad[1] = Y.at(0, 0)
                    } else {
                        if (Y.at(1, 1)) {
                            ad[0] = -Y.at(1, 1);
                            ad[1] = Y.at(1, 0)
                        } else {
                            ad[0] = 1;
                            ad[1] = 0
                        }
                    }
                    ay = ad[0] * ad[0] + ad[1] * ad[1];
                    ad[2] = -ad[1] * ae.y - ad[0] * ae.x;
                    for (an = 0; an < 3; an++) {
                        for (aq = 0; aq < 3; aq++) {
                            Y.data[an * 3 + aq] += ad[an] * ad[aq] / ay
                        }
                    }
                }
                ac = Math.abs(ab.x - ae.x);
                aa = Math.abs(ab.y - ae.y);
                if (ac <= 0.5 && aa <= 0.5) {
                    ah.curve.vertex[au] = new t(ab.x + ax, ab.y + W);
                    continue
                }
                am = V(Y, ae);
                af = ae.x;
                ao = ae.y;
                if (Y.at(0, 0) !== 0) {
                    for (Z = 0; Z < 2; Z++) {
                        ab.y = ae.y - 0.5 + Z;
                        ab.x = -(Y.at(0, 1) * ab.y + Y.at(0, 2)) / Y.at(0, 0);
                        ac = Math.abs(ab.x - ae.x);
                        ap = V(Y, ab);
                        if (ac <= 0.5 && ap < am) {
                            am = ap;
                            af = ab.x;
                            ao = ab.y
                        }
                    }
                }
                if (Y.at(1, 1) !== 0) {
                    for (Z = 0; Z < 2; Z++) {
                        ab.x = ae.x - 0.5 + Z;
                        ab.y = -(Y.at(1, 0) * ab.x + Y.at(1, 2)) / Y.at(1, 1);
                        aa = Math.abs(ab.y - ae.y);
                        ap = V(Y, ab);
                        if (aa <= 0.5 && ap < am) {
                            am = ap;
                            af = ab.x;
                            ao = ab.y
                        }
                    }
                }
                for (an = 0; an < 2; an++) {
                    for (aq = 0; aq < 2; aq++) {
                        ab.x = ae.x - 0.5 + an;
                        ab.y = ae.y - 0.5 + aq;
                        ap = V(Y, ab);
                        if (ap < am) {
                            am = ap;
                            af = ab.x;
                            ao = ab.y
                        }
                    }
                }
                ah.curve.vertex[au] = new t(af + ax, ao + W)
            }
        }
        function C(ab) {
            var ac = ab.curve,
            W = ac.n,
            X = ac.vertex,
            aa, Y, Z;
            for (aa = 0, Y = W - 1; aa < Y; aa++, Y--) {
                Z = X[aa];
                X[aa] = X[Y];
                X[Y] = Z
            }
        }
        function J(ah) {
            var X = ah.curve.n,
            W = ah.curve;
            var ab, aa, Z, ag, ac, Y, af, ae, ad;
            for (ab = 0; ab < X; ab++) {
                aa = U(ab + 1, X);
                Z = U(ab + 2, X);
                ad = S(1 / 2, W.vertex[Z], W.vertex[aa]);
                ac = y(W.vertex[ab], W.vertex[Z]);
                if (ac !== 0) {
                    ag = P(W.vertex[ab], W.vertex[aa], W.vertex[Z]) / ac;
                    ag = Math.abs(ag);
                    Y = ag > 1 ? (1 - 1 / ag) : 0;
                    Y = Y / 0.75
                } else {
                    Y = 4 / 3
                }
                W.alpha0[aa] = Y;
                if (Y >= r.alphamax) {
                    W.tag[aa] = "CORNER";
                    W.c[3 * aa + 1] = W.vertex[aa];
                    W.c[3 * aa + 2] = ad
                } else {
                    if (Y < 0.55) {
                        Y = 0.55
                    } else {
                        if (Y > 1) {
                            Y = 1
                        }
                    }
                    af = S(0.5 + 0.5 * Y, W.vertex[ab], W.vertex[aa]);
                    ae = S(0.5 + 0.5 * Y, W.vertex[Z], W.vertex[aa]);
                    W.tag[aa] = "CURVE";
                    W.c[3 * aa + 0] = af;
                    W.c[3 * aa + 1] = ae;
                    W.c[3 * aa + 2] = ad
                }
                W.alpha[aa] = Y;
                W.beta[aa] = 0.5
            }
            W.alphacurve = 1
        }
        function I(ai) {
            function at() {
                this.pen = 0;
                this.c = [new t(), new t()];
                this.t = 0;
                this.s = 0;
                this.alpha = 0
            }
            function W(aO, aV, aU, a1, aG, aK, aP) {
                var aR = aO.curve.n,
                aM = aO.curve,
                aW = aM.vertex,
                aT, aI, aH, aC, aS, aX, aE, aY, a0, aZ, aD, aB, az, ax, aQ, aN, aF, aA, ay, aw, av, aL, aJ;
                if (aV == aU) {
                    return 1
                }
                aT = aV;
                aS = U(aV + 1, aR);
                aI = U(aT + 1, aR);
                aC = aK[aI];
                if (aC === 0) {
                    return 1
                }
                aY = B(aW[aV], aW[aS]);
                for (aT = aI; aT != aU; aT = aI) {
                    aI = U(aT + 1, aR);
                    aH = U(aT + 2, aR);
                    if (aK[aI] != aC) {
                        return 1
                    }
                    if (T(G(aW[aV], aW[aS], aW[aI], aW[aH])) != aC) {
                        return 1
                    }
                    if (z(aW[aV], aW[aS], aW[aI], aW[aH]) < aY * B(aW[aI], aW[aH]) * -0.999847695156) {
                        return 1
                    }
                }
                aD = aM.c[U(aV, aR) * 3 + 2].copy();
                aB = aW[U(aV + 1, aR)].copy();
                az = aW[U(aU, aR)].copy();
                ax = aM.c[U(aU, aR) * 3 + 2].copy();
                aX = aP[aU] - aP[aV];
                aX -= P(aW[0], aM.c[aV * 3 + 2], aM.c[aU * 3 + 2]) / 2;
                if (aV >= aU) {
                    aX += aP[aR]
                }
                aA = P(aD, aB, az);
                ay = P(aD, aB, ax);
                aw = P(aD, az, ax);
                av = aA + aw - ay;
                if (ay == aA) {
                    return 1
                }
                aJ = aw / (aw - av);
                aL = ay / (ay - aA);
                aN = ay * aJ / 2;
                if (aN === 0) {
                    return 1
                }
                aF = aX / aN;
                aE = 2 - Math.sqrt(4 - aF / 0.3);
                a1.c[0] = S(aJ * aE, aD, aB);
                a1.c[1] = S(aL * aE, ax, az);
                a1.alpha = aE;
                a1.t = aJ;
                a1.s = aL;
                aB = a1.c[0].copy();
                az = a1.c[1].copy();
                a1.pen = 0;
                for (aT = U(aV + 1, aR); aT != aU; aT = aI) {
                    aI = U(aT + 1, aR);
                    aJ = D(aD, aB, az, ax, aW[aT], aW[aI]);
                    if (aJ < -0.5) {
                        return 1
                    }
                    aQ = H(aJ, aD, aB, az, ax);
                    aY = B(aW[aT], aW[aI]);
                    if (aY === 0) {
                        return 1
                    }
                    a0 = P(aW[aT], aW[aI], aQ) / aY;
                    if (Math.abs(a0) > aG) {
                        return 1
                    }
                    if (x(aW[aT], aW[aI], aQ) < 0 || x(aW[aI], aW[aT], aQ) < 0) {
                        return 1
                    }
                    a1.pen += a0 * a0
                }
                for (aT = aV; aT != aU; aT = aI) {
                    aI = U(aT + 1, aR);
                    aJ = D(aD, aB, az, ax, aM.c[aT * 3 + 2], aM.c[aI * 3 + 2]);
                    if (aJ < -0.5) {
                        return 1
                    }
                    aQ = H(aJ, aD, aB, az, ax);
                    aY = B(aM.c[aT * 3 + 2], aM.c[aI * 3 + 2]);
                    if (aY === 0) {
                        return 1
                    }
                    a0 = P(aM.c[aT * 3 + 2], aM.c[aI * 3 + 2], aQ) / aY;
                    aZ = P(aM.c[aT * 3 + 2], aM.c[aI * 3 + 2], aW[aI]) / aY;
                    aZ *= 0.75 * aM.alpha[aI];
                    if (aZ < 0) {
                        a0 = -a0;
                        aZ = -aZ
                    }
                    if (a0 < aZ - aG) {
                        return 1
                    }
                    if (a0 < aZ) {
                        a1.pen += (a0 - aZ) * (a0 - aZ)
                    }
                }
                return 0
            }
            var ag = ai.curve,
            al = ag.n,
            aq = ag.vertex,
            ak = new Array(al + 1),
            au = new Array(al + 1),
            ap = new Array(al + 1),
            X = new Array(al + 1),
            ab,
            ao,
            an,
            af,
            aj = new at(),
            Y,
            am,
            ar,
            aa,
            Z,
            ae,
            ad;
            var ac = new Array(al),
            ah = new Array(al + 1);
            for (ao = 0; ao < al; ao++) {
                if (ag.tag[ao] == "CURVE") {
                    ac[ao] = T(P(aq[U(ao - 1, al)], aq[ao], aq[U(ao + 1, al)]))
                } else {
                    ac[ao] = 0
                }
            }
            ar = 0;
            ah[0] = 0;
            Y = ag.vertex[0];
            for (ao = 0; ao < al; ao++) {
                am = U(ao + 1, al);
                if (ag.tag[am] == "CURVE") {
                    aa = ag.alpha[am];
                    ar += 0.3 * aa * (4 - aa) * P(ag.c[ao * 3 + 2], aq[am], ag.c[am * 3 + 2]) / 2;
                    ar += P(Y, ag.c[ao * 3 + 2], ag.c[am * 3 + 2]) / 2
                }
                ah[ao + 1] = ar
            }
            ak[0] = -1;
            au[0] = 0;
            ap[0] = 0;
            for (an = 1; an <= al; an++) {
                ak[an] = an - 1;
                au[an] = au[an - 1];
                ap[an] = ap[an - 1] + 1;
                for (ao = an - 2; ao >= 0; ao--) {
                    af = W(ai, ao, U(an, al), aj, r.opttolerance, ac, ah);
                    if (af) {
                        break
                    }
                    if (ap[an] > ap[ao] + 1 || (ap[an] == ap[ao] + 1 && au[an] > au[ao] + aj.pen)) {
                        ak[an] = ao;
                        au[an] = au[ao] + aj.pen;
                        ap[an] = ap[ao] + 1;
                        X[an] = aj;
                        aj = new at()
                    }
                }
            }
            ab = ap[al];
            Z = new p(ab);
            ae = new Array(ab);
            ad = new Array(ab);
            an = al;
            for (ao = ab - 1; ao >= 0; ao--) {
                if (ak[an] == an - 1) {
                    Z.tag[ao] = ag.tag[U(an, al)];
                    Z.c[ao * 3 + 0] = ag.c[U(an, al) * 3 + 0];
                    Z.c[ao * 3 + 1] = ag.c[U(an, al) * 3 + 1];
                    Z.c[ao * 3 + 2] = ag.c[U(an, al) * 3 + 2];
                    Z.vertex[ao] = ag.vertex[U(an, al)];
                    Z.alpha[ao] = ag.alpha[U(an, al)];
                    Z.alpha0[ao] = ag.alpha0[U(an, al)];
                    Z.beta[ao] = ag.beta[U(an, al)];
                    ae[ao] = ad[ao] = 1
                } else {
                    Z.tag[ao] = "CURVE";
                    Z.c[ao * 3 + 0] = X[an].c[0];
                    Z.c[ao * 3 + 1] = X[an].c[1];
                    Z.c[ao * 3 + 2] = ag.c[U(an, al) * 3 + 2];
                    Z.vertex[ao] = S(X[an].s, ag.c[U(an, al) * 3 + 2], aq[U(an, al)]);
                    Z.alpha[ao] = X[an].alpha;
                    Z.alpha0[ao] = X[an].alpha;
                    ae[ao] = X[an].s;
                    ad[ao] = X[an].t
                }
                an = ak[an]
            }
            for (ao = 0; ao < ab; ao++) {
                am = U(ao + 1, ab);
                Z.beta[ao] = ae[ao] / (ae[ao] + ad[am])
            }
            Z.alphacurve = 1;
            ai.curve = Z
        }
        for (var N = 0; N < g.length; N++) {
            var K = g[N];
            O(K);
            Q(K);
            w(K);
            M(K);
            if (K.sign === "-") {
                C(K)
            }
            J(K);
            if (r.optcurve) {
                I(K)
            }
        }
    }
    function j(w) {
        if (w) {
            c = w
        }
        if (!r.isReady) {
            setTimeout(j, 100);
            return
        }
        i();
        n();
        c();
        c = null
    }
    function k() {
        a = null;
        g = [];
        c = null;
        r.isReady = false
    }
    function s(I, F) {
        function H(M) {
            function L(P) {
                var O = "C " + (M.c[P * 3 + 0].x * I).toFixed(3) + " " + (M.c[P * 3 + 0].y * I).toFixed(3) + ",";
                O += (M.c[P * 3 + 1].x * I).toFixed(3) + " " + (M.c[P * 3 + 1].y * I).toFixed(3) + ",";
                O += (M.c[P * 3 + 2].x * I).toFixed(3) + " " + (M.c[P * 3 + 2].y * I).toFixed(3) + " ";
                return O
            }
            function J(O) {
                var P = "L " + (M.c[O * 3 + 1].x * I).toFixed(3) + " " + (M.c[O * 3 + 1].y * I).toFixed(3) + " ";
                P += (M.c[O * 3 + 2].x * I).toFixed(3) + " " + (M.c[O * 3 + 2].y * I).toFixed(3) + " ";
                return P
            }
            var N = M.n,
            w;
            var K = "M" + (M.c[(N - 1) * 3 + 2].x * I).toFixed(3) + " " + (M.c[(N - 1) * 3 + 2].y * I).toFixed(3) + " ";
            for (w = 0; w < N; w++) {
                if (M.tag[w] === "CURVE") {
                    K += L(w)
                } else {
                    if (M.tag[w] === "CORNER") {
                        K += J(w)
                    }
                }
            }
            return K
        }
        var G = a.w * I,
        C = a.h * I,
        D = g.length,
        E, A, x, z, y;
        var B = '<svg id="svg" version="1.1" width="' + G + '" height="' + C + '" xmlns="http://www.w3.org/2000/svg">';
        B += '<path d="';
        for (A = 0; A < D; A++) {
            E = g[A].curve;
            B += H(E)
        }
        if (F === "curve") {
            x = "black";
            z = "none";
            y = ""
        } else {
            x = "none";
            z = "black";
            y = ' fill-rule="evenodd"'
        }
        B += '" stroke="' + x + '" fill="' + z + '"' + y + "/></svg>";
        return B
    }
    function o(K, y) {
        var G = [];
        var I = [];
        var F = [];
        function J(O) {
            var w = new THREE.Shape();
            function N(Q) {
                w.bezierCurveTo(O.c[Q * 3 + 0].x * K, O.c[Q * 3 + 0].y * K, O.c[Q * 3 + 1].x * K, O.c[Q * 3 + 1].y * K, O.c[Q * 3 + 2].x * K, O.c[Q * 3 + 2].y * K)
            }
            function M(Q) {
                w.lineTo(O.c[Q * 3 + 1].x * K, O.c[Q * 3 + 1].y * K);
                w.lineTo(O.c[Q * 3 + 2].x * K, O.c[Q * 3 + 2].y * K)
            }
            var P = O.n,
            L;
            w.moveTo(O.c[(P - 1) * 3 + 2].x * K, O.c[(P - 1) * 3 + 2].y * K);
            for (L = 0; L < P; L++) {
                if (O.tag[L] === "CURVE") {
                    N(L)
                } else {
                    if (O.tag[L] === "CORNER") {
                        M(L)
                    }
                }
            }
            G.push(w.extractAllPoints(y).shape)
        }
        var H = a.w * K,
        B = a.h * K,
        D = g.length,
        E, A;
        console.log("len=>" + D);
        for (A = 0; A < D; A++) {
            E = g[A].curve;
            J(E);
            var C = [];
            var x = [];
            for (var z = 0; z < G[A].length; z++) {
                C.push({
                    X: G[A][z].x,
                    Y: G[A][z].y
                });
                x.push(G[A][z].x, G[A][z].y)
            }
            I.push(C);
            F.push(x)
        }
        return I
    }
    function d() {
        if (r.isReady) {
            k();
            l()
        }
    }
    return {
        loadImageFromFile: b,
        loadImageFromUrl: v,
        setParameter: u,
        process: j,
        getSVG: s,
        getPolygons: o,
        reBuild: d,
        img: h
    }
})();